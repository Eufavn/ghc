<?xml version="1.0" encoding="iso-8859-1"?>
<sect1 id="safe-haskell">
  <title>Safe Haskell</title>
  
  Safe Haskell is an extension to the Haskell language supported by GHC, that
  provides certain safety guarantees about Haskell code compiled using this
  extension. It allows people to build more advance security mechanisms on top
  of Haskell and for the safe execution of untrusted Haskell code. Its purpose
  isn't to provide a complete secure execution environment for Haskell code but
  to give users enough guarantees about the Haskell language to be able to
  build such systems. Its design is similar to the safe and unsafe module
  system supported by the Modula-3 language.
  
  The design of Safe Haskell covers the following aspects:
  <itemizedlist>
    <listitem>A <link linkend="safe-language-overview">safe language</link>
      dialect of Haskell that provides guarantees about the code. Mainly it
      allows the types and module boundaries to be trusted.
    </listitem>
    <listitem>A new <emphasis>safe import</emphasis> extension that specifies
      the module being imported must be trusted.
    </listitem>
    <listitem>A definition of <emphasis>trust</emphasis> (or safety) and how it
      operates, along with ways of defining and changing the trust of modules
      and packages.
    </listitem>
  </itemizedlist>
  
  <sect2 id="safe-language-overview">
    <title>Safe Language Overview</title>

    The Safe Haskell <emphasis>Safe language</emphasis> guarantees the
    following properties:
    <itemizedlist>
      <listitem><emphasis>Referential transparency.</emphasis> Functions
        in the Safe language are deterministic, evaluating them will not
        cause any side effects. Functions in the <emphasis>IO</emphasis>
        monad are still allowed and behave as usual but any pure function
        as according to the functions type is guaranteed to indeed be
        pure. This property allows a user of the Safe language to trust
        the types of functions.
      </listitem>
      <listitem><emphasis>Module boundary control.</emphasis> Haskell code
        compiled using the Safe language is guaranteed to only access
        symbols that are publicly available to it through other modules
        export lists. An import part of this is that safe compiled code
        is not able to examine or create data values using data constructors
        that the module cannot import. If a module M establishes some
        invariants through careful use of its export list then code
        compiled using the Safe language that imports M is guaranteed to
        respect those invariants.
      </listitem>
      <listitem><emphasis>Semantic consistency.</emphasis> The Safe language
        is strictly a subset of Haskell as implemented by GHC. Any expression
        that compiles in the safe language has the same meaning as it does
        when compiled in normal Haskell. In addition, in any module that imports
        a Safe language module, expressions that compile both with and without
        the safe import have the same meaning in both cases. That is, importing
        a module using the Safe language cannot change the meaning of existing
        code that isn't dependent on that module.
      </listitem>
    </itemizedlist>
    
    Put simply, these three properties guarantee that you can trust the types
    in the Safe language, can trust that module export lists are respected
    in the Safe language and can trust that code which successfully compiles
    in the Safe language has the same meaning as it normally would. Please see
    <xref linkend="safe-language"/> for a more detailed view of the safe
    language.
  </sect2>

  <sect2 id="safe-imports">
    <title>Safe Imports</title>

    Safe Haskell enables a small extension to the usual import syntax of
    Haskell, adding a <emphasis>safe</emphasis> keyword:

    <programlisting>
      impdecl -> import [safe] [qualified] modid [as modid] [impspec]
    </programlisting>

    When used, the module being imported with the safe keyword must be a trusted
    module, otherwise a compilation error will occur. The safe import extension
    is enabled by either of the <emphasis>-XSafe</emphasis>,
    <emphasis>-XTrustworthy</emphasis>, <emphasis>-XSafeLanguage</emphasis> or
    <emphasis>-XSafeImports</emphasis> flags and corresponding PRAGMA's. When
    either the <emphasis>-XSafe</emphasis> or
    <emphasis>-XSafeLanguage</emphasis> flag is used, the safe keyword is
    allowed but meaningless -- all imports are safe regardless.
  </sect2>

  <sect2 id="safe-trust">
    <title>Trust</title>

    The Safe Haskell extension introduces the following two new language flags:
    <itemizedlist>
      <listitem><emphasis>-XSafe:</emphasis> Enables the Safe language dialect,
      asking GHC to guarantee trust. The safe language dialect requires that
      all imports be trusted or a compile error will occur.</listitem>
      <listitem><emphasis>-XTrustworthy:</emphasis> Means that while this module
      may invoke unsafe functions internally, the module's author claims that
      it exports an API that can't be used in an unsafe way. This doesn't enable
      the Safe language or place any restrictions on the allowed Haskell code.
      The trust guarantee is provided by the module author, not GHC. An import
      statement with the safe keyword results in a compilation error if the
      imported module is not trussted. An import statement without the keyword
      behaves as usual and can import any module whether trusted or
      not.</listitem>
    </itemizedlist>

    Whether or not a module is trusted depends on a notion of trust for
    packages, which is determined by the client C invoking GHC (i.e., you). A
    package <emphasis>P</emphasis> is trusted when either C's package database
    records that <emphasis>P</emphasis> is trusted (and no command-line
    arguments override this), or C's command-line flags say to trust it
    regardless of what is recorded in the package database. In either case, C
    is the only authority on package trust. It is up to the client to decide
    which packages they trust.

    Now a <emphasis>module M in a package P is trusted by a client C</emphasis>
    if and only if:
    <itemizedlist>
      <listitem>Both of these hold:
        <itemizedlist>
          <listitem> The module was compiled with <emphasis>-XSafe</emphasis></listitem>
          <listitem> All of M's direct imports are trusted by C</listitem>
        </itemizedlist>
      </listitem>
      <listitem><emphasis>OR</emphasis> all of these hold:
        <itemizedlist>
          <listitem>The module was compiled with <emphasis>-XTrustworthy</emphasis></listitem>
          <listitem>All of M's direct safe imports are trusted by C</listitem>
          <listitem>Package P is trusted by C</listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    For the first trust definition the trust guarantee is provided by GHC
    through the restrictions imposed by the Safe language. For the second
    definition of trust, the guarantee is provided initially by the
    module author. The client C then establishes that they trust the
    module author by indicating they trust the package the module resides
    in. This trust chain is required as GHC provides no guarantee for
    <emphasis>-XTrustworthy</emphasis> compiled modules.

    <sect3 id="safe-trust-example">
       <title>Example</title>

       <programlisting>
         Package Wuggle:
            {-# LANGUAGE Safe #-}
            module Buggle where
              import Prelude
              f x = ...blah...
              
         Package P:
            {-# LANGUAGE Trustworthy #-}
            module M where
              import System.IO.Unsafe
              import safe Buggle
       </programlisting>

       Suppose a client C decides to trust package P. Then does C trust module M?
       To decide, GHC must check M's imports: M imports System.IO.Unsafe. M was
       compiled with -XTrustworthy, so P's author takes responsibility for that
       import. C trusts P's author, so C trusts M to only use its unsafe
       imports (System.IO.Unsafe in this example)in a safe and consistent
       manner with respect the API M exposes.  M also has a safe import of
       Buggle, so for this import P's author takes no responsibility for the
       safety or otherwise.  So GHC must check whether Buggle is trusted by C.
       Is it? Well, it is compiled with -XSafe, so the code in Buggle itself is
       machine-checked to be OK, but again under the assumption that all of
       Buggle's imports are trusted by C. Prelude comes from base, which C
       trusts, and is compiled with -XTrustworthy (While Prelude is typically
       imported implicitly, it still obeys the same rules outlined here).  So
       Buggle is considered trusted.

       Notice that C didn't need to trust package Wuggle; the machine checking
       is enough. C only needs to trust packages that have -XTrustworthy
       modules in them.
    </sect3>

    <sect3 id="safe-no-trust">
       <title>Safe Language &amp; Imports without Trust</title>

       Safe Haskell also allows the new language extensions -- the Safe language
       dialect and safe imports -- to be used independtly of any trust
       assertions for the code.

       <itemizedlist>
          <listitem><emphasis>-XSafeImports</emphasis>: enables the safe import
             extension. The module using this feature is left untrusted
             though.</listitem>
          <listitem><emphasis>-XSafeLanguage</emphasis>:
             enables the safe language extension. The module using this feature
             is left untrusted though.</listitem>
       </itemizedlist>

       These are extensions are useful for encouraging good programming style and
       also for flexibility during development when using Safe Haskell. The Safe
       language encourages users to avoid liberal use of unsafe Haskell language
       features. There are also situations where a module may only use the Safe
       language subset but exposes some internal API's that code using
       <emphasis>-XSafe</emphasis> shouldn't be allowed to access for security
       reasons. Please see <link linkend="safe-use-cases">Safe Haskell use
       cases</link> for a more detailed explanation.
    </sect3>

    <sect3 id="safe-flag-summary">
       <title>Safe Haskell Flag Summary</title>

       In summary, Safe Haskell consists of the following language flags:

       <itemizedlist>
         <listitem>
           <emphasis>-XSafe</emphasis>
           <itemizedlist>
             <listitem>To be trusted, all of the module's direct imports must be
               trusted, but the module itself need not reside in a trusted
               package, because the compiler vouches for its trustworthiness. The
               "safe" keyword is allowed but meaningless in import statements --
               conceptually every import is safe whether or not so
               tagged.</listitem>
             <listitem><emphasis>Module Trusted:</emphasis> Yes</listitem>
             <listitem><emphasis>Haskell Language:</emphasis> Restricted to Safe
               Language</listitem>
             <listitem><emphasis>Imported Modules:</emphasis> All forced to be
               safe imports, all must be trusted.</listitem>
           </itemizedlist>
         </listitem>
         <listitem>
           <emphasis>-XSafeLanguage:</emphasis>
           <itemizedlist>
             <listitem>The module is never trusted, because the author does not
               claim it is trustworthy. As long as the module compiles both ways,
               the result is identical whether or not the -XSafeLanguage flag is
               supplied. As with -XSafe, the "safe" import keyword is allowed but
               meaningless -- all imports must be safe.</listitem>
             <listitem><emphasis>Module Trusted:</emphasis> No</listitem>
             <listitem><emphasis>Haskell Language:</emphasis> Restricted to Safe
               Language</listitem>
             <listitem><emphasis>Imported Modules:</emphasis> All forced to be
               safe imports, all must be trusted.</listitem>
           </itemizedlist>
         </listitem>
         <listitem>
           <emphasis>-XTrustworthy:</emphasis>
           <itemizedlist>
             <listitem>This establishes that the module is trusted, but the
               guarantee is provided by the module's author. A client of this
               module then specifies that they trust the module author by
               specifying they trust the package containing the module.
               '-XTrustworthy' has no effect on the accepted range of Haskell
               programs or their semantics, except that they allow the safe
               import keyword.</listitem>
               <listitem><emphasis>Module Trusted:</emphasis> Yes but only if
                 Package the module resides in is also trusted.</listitem>
               <listitem><emphasis>Haskell Language:</emphasis> Unrestricted
               </listitem>
               <listitem><emphasis>Imported Modules:</emphasis> Under control
                 of module author which ones must be trusted.</listitem>
           </itemizedlist> 
         </listitem>
         <listitem>
           <emphasis>-XSafeLanguage -XTrustworthy:</emphasis>
           <itemizedlist>
             <listitem>For the trust property this has the same effect as
               '-XTrustworthy' by itself. However unlike -XTrustworthy it also
               restricts the range of acceptable Haskell programs to the Safe
               language. The difference from this and using -XSafe is the
               different trust type and that not all imports are forced to be
               safe imports, they are instead optionally specified by the module
               author.</listitem>
             <listitem><emphasis>Module Trusted:</emphasis> Yes but only if Package
               the module resides in is also trusted.</listitem>
             <listitem><emphasis>Haskell Language:</emphasis> Restricted to Safe
               Language</listitem>
             <listitem><emphasis>Imported Modules:</emphasis> Under control of
               module author which ones must be trusted.</listitem>
           </itemizedlist>
         </listitem>
         <listitem>
           <emphasis>-XSafeImport:</emphasis>
           <itemizedlist>
             <listitem>Enable the Safe Import extension so that a module can
               require a dependency to be trusted without asserting any trust
               about itself.</listitem>
             <listitem><emphasis>Module Trusted:</emphasis> No</listitem>
             <listitem><emphasis>Haskell Language:</emphasis>
               Unrestricted</listitem>
             <listitem><emphasis>Imported Modules:</emphasis> Under control of
               module author which ones must be trusted.</listitem>
           </itemizedlist>
         </listitem>
       </itemizedlist>
    </sect3>

    <sect3 id="safe-package-trust">
      <title>Package Trust</title>

      Safe Haskell gives packages a new boolean property, that of trust. Several new options are available
      at the GHC command-line to specify the trust property of packages:

      <itemizedlist>
        <listitem><emphasis>-trust P</emphasis>: Exposes package P if it was
          hidden and considers it a trusted package regardless of the package
          database.</listitem>
       <listitem><emphasis>-distrust P</emphasis>: Exposes package P if it was
          hidden and considers it an untrusted package regardless of the
          package database.</listitem>
       <listitem><emphasis>-distrust-all-packages</emphasis>: Considers all
          packages distrusted unless they are explicitly set to be trusted by
          subsequent command-line options.</listitem>
      </itemizedlist>

      To set a package's trust property in the package database please refer to <xref linkend="packages"/>.
    </sect3>

  </sect2>

  <sect2 id="safe-language">
    <title>Safe Language Details</title>

    In the Safe language dialect we disable completely the following Haskell language features: 
    <itemizedlist>
      <listitem><emphasis>GeneralizedNewtypeDeriving:</emphasis> It can be used
        to violate constructor access control, by allowing untrusted code to
        manipulate protected data types in ways the data type author did not
        intend. For example can be used to break invariants of data
        structures.</listitem>
      <listitem><emphasis>TemplateHaskell:</emphasis> Is particularly
        dangerous, as it can cause side effects even at compilation time and
        can be used to access abstract data types. It is very easy to break
        module boundaries with TH.</listitem>
   </itemizedlist>

    In the Safe language dialect we restrict the following Haskell language features: 
    <itemizedlist>
      <listitem><emphasis>ForeignFunctionInterface:</emphasis> This is mostly
        safe, but foreign import declarations that import a function with a
        non-IO type are disallowed. All FFI imports must reside in the IO
        Monad.</listitem>
      <listitem><emphasis>RULES:</emphasis> As they can change the behaviour of
        trusted code in unanticipated ways, violating semantic consistency they
        are restricted in function. Specifically any RULES defined in a module
        M compiled with -XSafe or -XSafeLanguage are dropped. RULES defined in
        trustworthy modules that M imports are still valid and will fire as
        usual.</listitem>
      <listitem><emphasis>OverlappingInstances:</emphasis> This extension
        can be used to violate semantic consistency, because malicious code
        could redefine a type instance (by containing a more specific
        instance definition) in a way that changes the behaviour of code
        importing the untrusted module. The extension is not disabled for a
        module M compiled with -XSafe or -XSafeLanguage but restricted.
        While M can define overlapping instance declarations, they can
        only overlap other instance declaration defined in M. If in a module N
        that imports M, at a call site that uses  type-class function there is
        a choice of which instance to use (i.e. overlapping) and the most
        specific instances is from M, then all the other choices must also be
        from M. If not, a compilation error will occur. A simple way to think
        of this is a <emphasis>same origin policy</emphasis> for overlapping
        instances defined in Safe compiled modules.</listitem>
    </itemizedlist>
  </sect2>

  <sect2 id="safe-use-cases">
    <title>Use Cases</title>

    Safe Haskell has been designed with the following use cases in mind.
   
    <sect3>
      <title>Enforcing Good Programming Style</title>

      Over-reliance on magic functions such as unsafePerformIO or magic symbols
      such as realWorld# can lead to less elegant Haskell code. The Safe dialect
      formalizes this notion of magic and prohibits its use. Thus, people may
      encourage their collaborators to use the Safe dialect, except when truly
      necessary, so as to promote better programming style. It can be thought
      of as an addition to using <option>-Wall -Werror</option>.
    </sect3>

    <sect3>
      <title>Building Secure Systems (restricted IO Monads)</title>

      The original use case that Safe Haskell was designed for was to allow
      secure systems to be built on top of the Haskell programming language.
      Many researchers have done great work with Haskell, building such systems
      as information flow control security systems, capability based security
      system, languages for working with encrypted data... etc. These systems
      all rely on properties of the Haskell language that aren't true in the
      general case where uses of functions like
      <emphasis>unsafePerformIO</emphasis> are allowed. Safe Haskell however
      gives enough guarantees about the compiled Haskell code to be able to
      successfully build secure systems on top of.

      As an example lets define an interface for a plugin system where the
      plugin authors are untrusted, possibly malicious third-parties. We do
      this by restricting the interface to pure functions or to a restricted IO
      monad that we have defined that only allows a safe subset of IO actions
      to be executed. We define the plugin interface here so that it requires
      the plugin module, <emphasis>Danger</emphasis>, to export a single
      computation, <emphasis>Danger.runMe</emphasis>, of type <emphasis>RIO
        ()</emphasis>, where <emphasis>RIO</emphasis> is a new monad defined as
      follows:

      <programlisting>
        -- Either of the following pragmas would do
        {-# LANGUAGE Trustworthy #-}
        {-# LANGUAGE Safe #-}

        module RIO (RIO(), runRIO, rioReadFile, rioWriteFile) where

        -- Notice that symbol UnsafeRIO is not exported from this module!

        newtype RIO a = UnsafeRIO { runRIO :: IO a }

        instance Monad RIO where
            return = UnsafeRIO . return
            (UnsafeRIO m) >>= k = UnsafeRIO $ m >>= runRIO . k

        -- Returns True iff access is allowed to file name
        pathOK :: FilePath -> IO Bool
        pathOK file = {- Implement some policy based on file name -}

        rioReadFile :: FilePath -> RIO String
        rioReadFile file = UnsafeRIO $ do
          ok &lt;- pathOK file
          if ok then readFile file else return ""

        rioWriteFile :: FilePath -> String -> RIO ()
        rioWriteFile file contents = UnsafeRIO $ do
          ok &lt;- pathOK file
          if ok then writeFile file contents else return () 
      </programlisting>

      We compile Danger using the -XSafe flag. Danger can import module RIO
      because RIO is marked Trustworthy. Thus, Danger can make use of the
      rioReadFile and rioWriteFile functions to access permitted file names. 

      The main application then imports both RIO and Danger. To run the
      plugin, it calls RIO.runRIO Danger.runMe within the IO monad. The
      application is safe in the knowledge that the only IO to ensue will be
      to files whose paths were approved by the pathOK test. We are relying on
      the fact that the type system and constructor privacy prevent RIO
      computations from executing IO actions directly. Only functions with
      access to privileged symbol UnsafeRIO can lift IO computations into the
      RIO monad. 
    </sect3>

    <sect3>
      <title>Uses of -XSafeImports</title>

      If you are writing a module and want to import a module from an untrusted
      author, then you would use the following syntax:

      <programlisting>
        import safe Untrusted.Module
      </programlisting>

      As the safe import keyword is a feature of Safe Haskell and not Haskell98
      this would fail though unless you enabled Safe imports through on the of
      the Safe Haskell language flags. Three flags enable safe imports,
      <emphasis>-XSafe, -XTrustworthy</emphasis> and
      <emphasis>-XSafeImports</emphasis>. However <emphasis>-XSafe and
        -XTrustworthy</emphasis> do more then just enable the keyword which may
      be undesirable. Using the <emphasis>-XSafeImports</emphasis> language flag
      allows you to enable safe imports and nothing more.
    </sect3>

    <sect3>
      <title>Uses of -XSafeLanguage</title>

      The <emphasis>-XSafeLanguage</emphasis> flag has two use cases. Firstly
      as stated above it can be used to enforce good programming style.
      Secondly, in the <emphasis>RIO</emphasis> restricted IO monad example
      above there is no reason that it can't be implemented in the Safe
      Language as its code isn't reliant on any unsafe features of Haskell.
      However we may also wish to export the <emphasis>UnsafeRIO</emphasis>
      action in the defining module or <emphasis>RIO</emphasis> and then define
      a new module that only exports a safe subset of the original definition
      of <emphasis>RIO</emphasis>. The defining module can use the
      <emphasis>-XSafeLanguage</emphasis> flag and be assured that the
      untrusted <emphasis>Danger</emphasis> module can't import it.
    </sect3>
  </sect2>

</sect1>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter" "sect1") ***
     ;;; End: ***
 -->
